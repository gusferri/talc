{"ast":null,"code":"import { S as SelectionModel } from './selection-model-CeeHVIcP.mjs';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ViewContainerRef, Directive, TemplateRef, IterableDiffers, ChangeDetectorRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { T as TREE_KEY_MANAGER } from './tree-key-manager-KnCoIkIC.mjs';\nimport { D as Directionality } from './directionality-CBXD4hga.mjs';\nimport { i as isDataSource } from './data-source-D34wiQZj.mjs';\nimport { coerceObservable } from './coercion/private.mjs';\nimport './typeahead-9ZW4Dtsf.mjs';\nimport './keycodes-CpHkExLC.mjs';\nimport '@angular/common';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n  /** Saved data node for `expandAll` action. */\n  dataNodes;\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel = /*#__PURE__*/new SelectionModel(true);\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   */\n  trackBy;\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel;\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable;\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren;\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode) {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n  /** Expands one single data node. */\n  expand(dataNode) {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n  /** Collapses one single data node. */\n  collapse(dataNode) {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode) {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode) {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n  }\n  /** Collapse all dataNodes in the tree. */\n  collapseAll() {\n    this.expansionModel.clear();\n  }\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  _trackByValue(value) {\n    return this.trackBy ? this.trackBy(value) : value;\n  }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n  getLevel;\n  isExpandable;\n  options;\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(getLevel, isExpandable, options) {\n    super();\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode) {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results = [];\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n  getChildren;\n  options;\n  /** Construct with nested tree function getChildren. */\n  constructor(getChildren, options) {\n    super();\n    this.getChildren = getChildren;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode) {\n    const descendants = [];\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n  /** A helper function to get descendants recursively. */\n  _getDescendants(descendants, dataNode) {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach(child => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = /*#__PURE__*/new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nlet CdkTreeNodeOutlet = /*#__PURE__*/(() => {\n  class CdkTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, {\n      optional: true\n    });\n    constructor() {}\n    static ɵfac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeOutlet,\n      selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n    });\n  }\n  return CdkTreeNodeOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n  /** Data for the node. */\n  $implicit;\n  /** Depth of the node. */\n  level;\n  /** Index location of the node. */\n  index;\n  /** Length of the number of total dataNodes. */\n  count;\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nlet CdkTreeNodeDef = /*#__PURE__*/(() => {\n  class CdkTreeNodeDef {\n    /** @docs-private */\n    template = inject(TemplateRef);\n    /**\n     * Function that should return true if this node template should be used for the provided node\n     * data and index. If left undefined, this node will be considered the default node template to\n     * use when no other when functions return true for the data.\n     * For every node, there must be at least one when function that passes or an undefined to\n     * default.\n     */\n    when;\n    constructor() {}\n    static ɵfac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeDef,\n      selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"cdkTreeNodeDefWhen\", \"when\"]\n      }\n    });\n  }\n  return CdkTreeNodeDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nlet CdkTree = /*#__PURE__*/(() => {\n  class CdkTree {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality);\n    /** Subject that emits when the component has been destroyed. */\n    _onDestroy = new Subject();\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** Stores the node definition that does not have a when predicate. */\n    _defaultNodeDef;\n    /** Data subscription */\n    _dataSubscription;\n    /** Level of nodes */\n    _levels = new Map();\n    /** The immediate parents for a node. This is `null` if there is no parent. */\n    _parents = new Map();\n    /**\n     * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n     *\n     * Lookup key is the parent of a set. Root nodes have key of null.\n     *\n     * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n     * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n     */\n    _ariaSets = new Map();\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n    _dataSource;\n    /**\n     * The tree controller\n     *\n     * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a\n     * future version.\n     * @breaking-change 21.0.0\n     */\n    treeControl;\n    /**\n     * Given a data node, determines what tree level the node is at.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    levelAccessor;\n    /**\n     * Given a data node, determines what the children of that node are.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    childrenAccessor;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n     * relative to the function to know if a node should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    trackBy;\n    /**\n     * Given a data node, determines the key by which we determine whether or not this node is expanded.\n     */\n    expansionKey;\n    // Outlets within the tree's template where the dataNodes will be inserted.\n    _nodeOutlet;\n    /** The tree node template for the tree */\n    _nodeDefs;\n    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    /** Keep track of which nodes are expanded. */\n    _expansionModel;\n    /**\n     * Maintain a synchronous cache of flattened data nodes. This will only be\n     * populated after initial render, and in certain cases, will be delayed due to\n     * relying on Observable `getChildren` calls.\n     */\n    _flattenedNodes = new BehaviorSubject([]);\n    /** The automatically determined node type for the tree. */\n    _nodeType = new BehaviorSubject(null);\n    /** The mapping between data and the node that is rendered. */\n    _nodes = new BehaviorSubject(new Map());\n    /**\n     * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n     * from `_flattenedNodes` so they can be independently updated at different\n     * times.\n     */\n    _keyManagerNodes = new BehaviorSubject([]);\n    _keyManagerFactory = inject(TREE_KEY_MANAGER);\n    /** The key manager for this tree. Handles focus and activation based on user keyboard input. */\n    _keyManager;\n    _viewInit = false;\n    constructor() {}\n    ngAfterContentInit() {\n      this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n      this._updateDefaultNodeDefinition();\n      this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n      this.viewChange.complete();\n      this._onDestroy.next();\n      this._onDestroy.complete();\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // In certain tests, the tree might be destroyed before this is initialized\n      // in `ngAfterContentInit`.\n      this._keyManager?.destroy();\n    }\n    ngOnInit() {\n      this._checkTreeControlUsage();\n      this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n      this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n      const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n      if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n      this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    /**\n     * Sets the node type for the tree, if it hasn't been set yet.\n     *\n     * This will be called by the first node that's rendered in order for the tree\n     * to determine what data transformations are required.\n     */\n    _setNodeTypeIfUnset(newType) {\n      const currentType = this._nodeType.value;\n      if (currentType === null) {\n        this._nodeType.next(newType);\n      } else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n        console.warn(`Tree is using conflicting node types which can cause unexpected behavior. ` + `Please use tree nodes of the same type (e.g. only flat or only nested). ` + `Current node type: \"${currentType}\", new node type \"${newType}\".`);\n      }\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // Remove the all dataNodes if there is now no data source\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n      this._dataSource = dataSource;\n      if (this._nodeDefs) {\n        this._subscribeToDataChanges();\n      }\n    }\n    _getExpansionModel() {\n      if (!this.treeControl) {\n        this._expansionModel ??= new SelectionModel(true);\n        return this._expansionModel;\n      }\n      return this.treeControl.expansionModel;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _subscribeToDataChanges() {\n      if (this._dataSubscription) {\n        return;\n      }\n      let dataStream;\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (isObservable(this._dataSource)) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n      if (!dataStream) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          throw getTreeNoValidDataSourceError();\n        }\n        return;\n      }\n      this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {\n        this._renderDataChanges(renderingData);\n      });\n    }\n    /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n    _getRenderData(dataStream) {\n      const expansionModel = this._getExpansionModel();\n      return combineLatest([dataStream, this._nodeType,\n      // We don't use the expansion data directly, however we add it here to essentially\n      // trigger data rendering when expansion changes occur.\n      expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n        this._emitExpansionChanges(expansionChanges);\n      }))]).pipe(switchMap(([data, nodeType]) => {\n        if (nodeType === null) {\n          return of({\n            renderNodes: data,\n            flattenedNodes: null,\n            nodeType\n          });\n        }\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline, which necessitates converting the data\n        return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({\n          ...convertedData,\n          nodeType\n        })));\n      }));\n    }\n    _renderDataChanges(data) {\n      if (data.nodeType === null) {\n        this.renderNodeChanges(data.renderNodes);\n        return;\n      }\n      // If we're here, then we know what our node type is, and therefore can\n      // perform our usual rendering pipeline.\n      this._updateCachedData(data.flattenedNodes);\n      this.renderNodeChanges(data.renderNodes);\n      this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n      if (!expansionChanges) {\n        return;\n      }\n      const nodes = this._nodes.value;\n      for (const added of expansionChanges.added) {\n        const node = nodes.get(added);\n        node?._emitExpansionState(true);\n      }\n      for (const removed of expansionChanges.removed) {\n        const node = nodes.get(removed);\n        node?._emitExpansionState(false);\n      }\n    }\n    _initializeKeyManager() {\n      const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n        const node = renderNodes.get(this._getExpansionKey(data));\n        if (node) {\n          items.push(node);\n        }\n        return items;\n      }, [])));\n      const keyManagerOptions = {\n        trackBy: node => this._getExpansionKey(node.data),\n        skipPredicate: node => !!node.isDisabled,\n        typeAheadDebounceInterval: true,\n        horizontalOrientation: this._dir.value\n      };\n      this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n      // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n      const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n      this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n        // childrenAccessor. Throw an appropriate error if contract is not met.\n        let numTreeControls = 0;\n        if (this.treeControl) {\n          numTreeControls++;\n        }\n        if (this.levelAccessor) {\n          numTreeControls++;\n        }\n        if (this.childrenAccessor) {\n          numTreeControls++;\n        }\n        if (!numTreeControls) {\n          throw getTreeControlMissingError();\n        } else if (numTreeControls > 1) {\n          throw getMultipleTreeControlsError();\n        }\n      }\n    }\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n      const changes = dataDiffer.diff(data);\n      // Some tree consumers expect change detection to propagate to nodes\n      // even when the array itself hasn't changed; we explicitly detect changes\n      // anyways in order for nodes to update their data.\n      //\n      // However, if change detection is called while the component's view is\n      // still initing, then the order of child views initing will be incorrect;\n      // to prevent this, we only exit early if the view hasn't initialized yet.\n      if (!changes && !this._viewInit) {\n        return;\n      }\n      changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex);\n          viewContainer.move(view, currentIndex);\n        }\n      });\n      // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n      // context to reflect the new object.\n      changes?.forEachIdentityChange(record => {\n        const newData = record.item;\n        if (record.currentIndex != undefined) {\n          const view = viewContainer.get(record.currentIndex);\n          view.context.$implicit = newData;\n        }\n      });\n      // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n      // the call stack since this method is called recursively (see #29733.)\n      // TODO: change to `this._changeDetectorRef.markForCheck()`,\n      // or just switch this component to use signals.\n      if (parentData) {\n        this._changeDetectorRef.markForCheck();\n      } else {\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n      if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n      return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData, index, viewContainer, parentData) {\n      const levelAccessor = this._getLevelAccessor();\n      const node = this._getNodeDef(nodeData, index);\n      const key = this._getExpansionKey(nodeData);\n      // Node context that will be provided to created embedded view\n      const context = new CdkTreeNodeOutletContext(nodeData);\n      parentData ??= this._parents.get(key) ?? undefined;\n      // If the tree is flat tree, then use the `getLevel` function in flat tree control\n      // Otherwise, use the level of parent node.\n      if (levelAccessor) {\n        context.level = levelAccessor(nodeData);\n      } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n        context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n      } else {\n        context.level = 0;\n      }\n      this._levels.set(key, context.level);\n      // Use default tree nodeOutlet, or nested node's nodeOutlet\n      const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index);\n      // Set the data to just created `CdkTreeNode`.\n      // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n      //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n    /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n    isExpanded(dataNode) {\n      return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n    toggle(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggle(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.toggle(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Expand the data node. If it is already expanded, does nothing. */\n    expand(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expand(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.select(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Collapse the data node. If it is already collapsed, does nothing. */\n    collapse(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapse(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.deselect(this._getExpansionKey(dataNode));\n      }\n    }\n    /**\n     * If the data node is currently expanded, collapse it and all its descendants.\n     * Otherwise, expand it and all its descendants.\n     */\n    toggleDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggleDescendants(dataNode);\n      } else if (this._expansionModel) {\n        if (this.isExpanded(dataNode)) {\n          this.collapseDescendants(dataNode);\n        } else {\n          this.expandDescendants(dataNode);\n        }\n      }\n    }\n    /**\n     * Expand the data node and all its descendants. If they are already expanded, does nothing.\n     */\n    expandDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expandDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.select(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n    collapseDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapseDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.deselect(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Expands all data nodes in the tree. */\n    expandAll() {\n      if (this.treeControl) {\n        this.treeControl.expandAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n      }\n    }\n    /** Collapse all data nodes in the tree. */\n    collapseAll() {\n      if (this.treeControl) {\n        this.treeControl.collapseAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n      }\n    }\n    /** Level accessor, used for compatibility between the old Tree and new Tree */\n    _getLevelAccessor() {\n      return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    /** Children accessor, used for compatibility between the old Tree and new Tree */\n    _getChildrenAccessor() {\n      return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    /**\n     * Gets the direct children of a node; used for compatibility between the old tree and the\n     * new tree.\n     */\n    _getDirectChildren(dataNode) {\n      const levelAccessor = this._getLevelAccessor();\n      const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n      if (!expansionModel) {\n        return of([]);\n      }\n      const key = this._getExpansionKey(dataNode);\n      const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n        if (changes.added.includes(key)) {\n          return of(true);\n        } else if (changes.removed.includes(key)) {\n          return of(false);\n        }\n        return EMPTY;\n      }), startWith(this.isExpanded(dataNode)));\n      if (levelAccessor) {\n        return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n          if (!expanded) {\n            return [];\n          }\n          return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n        }));\n      }\n      const childrenAccessor = this._getChildrenAccessor();\n      if (childrenAccessor) {\n        return coerceObservable(childrenAccessor(dataNode) ?? []);\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Given the list of flattened nodes, the level accessor, and the level range within\n     * which to consider children, finds the children for a given node.\n     *\n     * For example, for direct children, `levelDelta` would be 1. For all descendants,\n     * `levelDelta` would be Infinity.\n     */\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n      const key = this._getExpansionKey(dataNode);\n      const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n      const dataNodeLevel = levelAccessor(dataNode);\n      const expectedLevel = dataNodeLevel + levelDelta;\n      const results = [];\n      // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n      // descendants within a certain level range.\n      //\n      // If we reach a node whose level is equal to or less than the level of the tree node,\n      // we hit a sibling or parent's sibling, and should stop.\n      for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n        const currentLevel = levelAccessor(flattenedNodes[i]);\n        if (currentLevel <= dataNodeLevel) {\n          break;\n        }\n        if (currentLevel <= expectedLevel) {\n          results.push(flattenedNodes[i]);\n        }\n      }\n      return results;\n    }\n    /**\n     * Adds the specified node component to the tree's internal registry.\n     *\n     * This primarily facilitates keyboard navigation.\n     */\n    _registerNode(node) {\n      this._nodes.value.set(this._getExpansionKey(node.data), node);\n      this._nodes.next(this._nodes.value);\n    }\n    /** Removes the specified node component from the tree's internal registry. */\n    _unregisterNode(node) {\n      this._nodes.value.delete(this._getExpansionKey(node.data));\n      this._nodes.next(this._nodes.value);\n    }\n    /**\n     * For the given node, determine the level where this node appears in the tree.\n     *\n     * This is intended to be used for `aria-level` but is 0-indexed.\n     */\n    _getLevel(node) {\n      return this._levels.get(this._getExpansionKey(node));\n    }\n    /**\n     * For the given node, determine the size of the parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      return set.length;\n    }\n    /**\n     * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      const key = this._getExpansionKey(dataNode);\n      return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n    _getNodeParent(node) {\n      const parent = this._parents.get(this._getExpansionKey(node.data));\n      return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n    _getNodeChildren(node) {\n      return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n        const value = this._nodes.value.get(this._getExpansionKey(child));\n        if (value) {\n          nodes.push(value);\n        }\n        return nodes;\n      }, [])));\n    }\n    /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n    _sendKeydownToKeyManager(event) {\n      // Only handle events directly on the tree or directly on one of the nodes, otherwise\n      // we risk interfering with events in the projected content (see #29828).\n      if (event.target === this._elementRef.nativeElement) {\n        this._keyManager.onKeydown(event);\n      } else {\n        const nodes = this._nodes.getValue();\n        for (const [, node] of nodes) {\n          if (event.target === node._elementRef.nativeElement) {\n            this._keyManager.onKeydown(event);\n            break;\n          }\n        }\n      }\n    }\n    /** Gets all nested descendants of a given node. */\n    _getDescendants(dataNode) {\n      if (this.treeControl) {\n        return of(this.treeControl.getDescendants(dataNode));\n      }\n      if (this.levelAccessor) {\n        const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n        return of(results);\n      }\n      if (this.childrenAccessor) {\n        return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n          allChildren.push(...nextChildren);\n          return allChildren;\n        }, []));\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Gets all children and sub-children of the provided node.\n     *\n     * This will emit multiple times, in the order that the children will appear\n     * in the tree, and can be combined with a `reduce` operator.\n     */\n    _getAllChildrenRecursively(dataNode) {\n      if (!this.childrenAccessor) {\n        return of([]);\n      }\n      return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n        // Here, we cache the parents of a particular child so that we can compute the levels.\n        for (const child of children) {\n          this._parents.set(this._getExpansionKey(child), dataNode);\n        }\n        return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n      }));\n    }\n    _getExpansionKey(dataNode) {\n      // In the case that a key accessor function was not provided by the\n      // tree user, we'll default to using the node object itself as the key.\n      //\n      // This cast is safe since:\n      // - if an expansionKey is provided, TS will infer the type of K to be\n      //   the return type.\n      // - if it's not, then K will be defaulted to T.\n      return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n      const key = this._getExpansionKey(node);\n      const parent = this._parents.get(key);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n      const set = this._ariaSets.get(parentKey);\n      return set ?? [node];\n    }\n    /**\n     * Finds the parent for the given node. If this is a root node, this\n     * returns null. If we're unable to determine the parent, for example,\n     * if we don't have cached node data, this returns undefined.\n     */\n    _findParentForNode(node, index, cachedNodes) {\n      // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n      // our flattened list of nodes to determine the first node that's of a level lower than the\n      // provided node.\n      if (!cachedNodes.length) {\n        return null;\n      }\n      const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n      for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n        const parentNode = cachedNodes[parentIndex];\n        const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n        if (parentLevel < currentLevel) {\n          return parentNode;\n        }\n      }\n      return null;\n    }\n    /**\n     * Given a set of root nodes and the current node level, flattens any nested\n     * nodes into a single array.\n     *\n     * If any nodes are not expanded, then their children will not be added into the array.\n     * This will still traverse all nested children in order to build up our internal data\n     * models, but will not include them in the returned array.\n     */\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n      const childrenAccessor = this._getChildrenAccessor();\n      // If we're using a level accessor, we don't need to flatten anything.\n      if (!childrenAccessor) {\n        return of([...nodes]);\n      }\n      return of(...nodes).pipe(concatMap(node => {\n        const parentKey = this._getExpansionKey(node);\n        if (!this._parents.has(parentKey)) {\n          this._parents.set(parentKey, null);\n        }\n        this._levels.set(parentKey, level);\n        const children = coerceObservable(childrenAccessor(node));\n        return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n          this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n          for (const child of childNodes ?? []) {\n            const childKey = this._getExpansionKey(child);\n            this._parents.set(childKey, node);\n            this._levels.set(childKey, level + 1);\n          }\n        }), switchMap(childNodes => {\n          if (!childNodes) {\n            return of([]);\n          }\n          return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));\n        })));\n      }), reduce((results, children) => {\n        results.push(...children);\n        return results;\n      }, []));\n    }\n    /**\n     * Converts children for certain tree configurations.\n     *\n     * This also computes parent, level, and group data.\n     */\n    _computeRenderingData(nodes, nodeType) {\n      // The only situations where we have to convert children types is when\n      // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n      // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n      // nested.\n      if (this.childrenAccessor && nodeType === 'flat') {\n        // clear previously generated data so we don't keep end up retaining data overtime causing\n        // memory leaks.\n        this._clearPreviousCache();\n        // This flattens children into a single array.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: flattenedNodes,\n          flattenedNodes\n        })));\n      } else if (this.levelAccessor && nodeType === 'nested') {\n        // In the nested case, we only look for root nodes. The CdkNestedNode\n        // itself will handle rendering each individual node's children.\n        const levelAccessor = this.levelAccessor;\n        return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n          renderNodes: rootNodes,\n          flattenedNodes: nodes\n        })), tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else if (nodeType === 'flat') {\n        // In the case of a TreeControl, we know that the node type matches up\n        // with the TreeControl, and so no conversions are necessary. Otherwise,\n        // we've already confirmed that the data model matches up with the\n        // desired node type here.\n        return of({\n          renderNodes: nodes,\n          flattenedNodes: nodes\n        }).pipe(tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else {\n        // clear previously generated data so we don't keep end up retaining data overtime causing\n        // memory leaks.\n        this._clearPreviousCache();\n        // For nested nodes, we still need to perform the node flattening in order\n        // to maintain our caches for various tree operations.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: nodes,\n          flattenedNodes\n        })));\n      }\n    }\n    _updateCachedData(flattenedNodes) {\n      this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n      this._keyManagerNodes.next(flattenedNodes);\n    }\n    /** Traverse the flattened node data and compute parents, levels, and group data. */\n    _calculateParents(flattenedNodes) {\n      const levelAccessor = this._getLevelAccessor();\n      if (!levelAccessor) {\n        return;\n      }\n      // clear previously generated data so we don't keep end up retaining data overtime causing\n      // memory leaks.\n      this._clearPreviousCache();\n      for (let index = 0; index < flattenedNodes.length; index++) {\n        const dataNode = flattenedNodes[index];\n        const key = this._getExpansionKey(dataNode);\n        this._levels.set(key, levelAccessor(dataNode));\n        const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n        this._parents.set(key, parent);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const group = this._ariaSets.get(parentKey) ?? [];\n        group.splice(index, 0, dataNode);\n        this._ariaSets.set(parentKey, group);\n      }\n    }\n    /** Invokes a callback with all node expansion keys. */\n    _forEachExpansionKey(callback) {\n      const toToggle = [];\n      const observables = [];\n      this._nodes.value.forEach(node => {\n        toToggle.push(this._getExpansionKey(node.data));\n        observables.push(this._getDescendants(node.data));\n      });\n      if (observables.length > 0) {\n        combineLatest(observables).pipe(take(1), takeUntil(this._onDestroy)).subscribe(results => {\n          results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n          callback(toToggle);\n        });\n      } else {\n        callback(toToggle);\n      }\n    }\n    /** Clears the maps we use to store parents, level & aria-sets in. */\n    _clearPreviousCache() {\n      this._parents.clear();\n      this._levels.clear();\n      this._ariaSets.clear();\n    }\n    static ɵfac = function CdkTree_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTree)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTree,\n      selectors: [[\"cdk-tree\"]],\n      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n        }\n      },\n      viewQuery: function CdkTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n      hostBindings: function CdkTree_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkTree_keydown_HostBindingHandler($event) {\n            return ctx._sendKeydownToKeyManager($event);\n          });\n        }\n      },\n      inputs: {\n        dataSource: \"dataSource\",\n        treeControl: \"treeControl\",\n        levelAccessor: \"levelAccessor\",\n        childrenAccessor: \"childrenAccessor\",\n        trackBy: \"trackBy\",\n        expansionKey: \"expansionKey\"\n      },\n      exportAs: [\"cdkTree\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n      template: function CdkTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkTreeNodeOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkTree;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nlet CdkTreeNode = /*#__PURE__*/(() => {\n  class CdkTreeNode {\n    _elementRef = inject(ElementRef);\n    _tree = inject(CdkTree);\n    _tabindex = -1;\n    _type = 'flat';\n    /**\n     * The role of the tree node.\n     *\n     * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n     * for tree node. This input will be removed in a future version.\n     * @breaking-change 21.0.0\n     */\n    get role() {\n      return 'treeitem';\n    }\n    set role(_role) {\n      // ignore any role setting, we handle this internally.\n    }\n    /**\n     * Whether or not this node is expandable.\n     *\n     * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n     * `NestedTreeControl`, this should be provided for correct node a11y.\n     */\n    get isExpandable() {\n      return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n      this._inputIsExpandable = isExpandable;\n      if (this.data && !this._isExpandable || !this._inputIsExpandable) {\n        return;\n      }\n      // If the node is being set to expandable, ensure that the status of the\n      // node is propagated\n      if (this._inputIsExpanded) {\n        this.expand();\n      } else if (this._inputIsExpanded === false) {\n        this.collapse();\n      }\n    }\n    get isExpanded() {\n      return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n      this._inputIsExpanded = isExpanded;\n      if (isExpanded) {\n        this.expand();\n      } else {\n        this.collapse();\n      }\n    }\n    /**\n     * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus\n     * or activate this node.\n     */\n    isDisabled;\n    /**\n     * The text used to locate this item during typeahead. If not specified, the `textContent` will\n     * will be used.\n     */\n    typeaheadLabel;\n    getLabel() {\n      return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** This emits when the node has been programatically activated or activated by keyboard. */\n    activation = new EventEmitter();\n    /** This emits when the node's expansion status has been changed. */\n    expandedChange = new EventEmitter();\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static mostRecentTreeNode = null;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** Emits when the node's data has changed. */\n    _dataChanges = new Subject();\n    _inputIsExpandable = false;\n    _inputIsExpanded = undefined;\n    /**\n     * Flag used to determine whether or not we should be focusing the actual element based on\n     * some user interaction (click or focus). On click, we don't forcibly focus the element\n     * since the click could trigger some other component that wants to grab its own focus\n     * (e.g. menu, dialog).\n     */\n    _shouldFocus = true;\n    _parentNodeAriaLevel;\n    /** The tree node's data. */\n    get data() {\n      return this._data;\n    }\n    set data(value) {\n      if (value !== this._data) {\n        this._data = value;\n        this._dataChanges.next();\n      }\n    }\n    _data;\n    /* If leaf node, return true to not assign aria-expanded attribute */\n    get isLeafNode() {\n      // If flat tree node data returns false for expandable property, it's a leaf node\n      if (this._tree.treeControl?.isExpandable !== undefined && !this._tree.treeControl.isExpandable(this._data)) {\n        return true;\n        // If nested tree node data returns 0 descendants, it's a leaf node\n      } else if (this._tree.treeControl?.isExpandable === undefined && this._tree.treeControl?.getDescendants(this._data).length === 0) {\n        return true;\n      }\n      return false;\n    }\n    get level() {\n      // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n      // aria-level off the parent node and use it as the level for this node (note aria-level is\n      // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n      return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    /** Determines if the tree node is expandable. */\n    _isExpandable() {\n      if (this._tree.treeControl) {\n        if (this.isLeafNode) {\n          return false;\n        }\n        // For compatibility with trees created using TreeControl before we added\n        // CdkTreeNode#isExpandable.\n        return true;\n      }\n      return this._inputIsExpandable;\n    }\n    /**\n     * Determines the value for `aria-expanded`.\n     *\n     * For non-expandable nodes, this is `null`.\n     */\n    _getAriaExpanded() {\n      if (!this._isExpandable()) {\n        return null;\n      }\n      return String(this.isExpanded);\n    }\n    /**\n     * Determines the size of this node's parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize() {\n      return this._tree._getSetSize(this._data);\n    }\n    /**\n     * Determines the index (starting from 1) of this node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet() {\n      return this._tree._getPositionInSet(this._data);\n    }\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n      this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n      this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged()).subscribe(() => this._changeDetectorRef.markForCheck());\n      this._tree._setNodeTypeIfUnset(this._type);\n      this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n      // If this is the last tree node being destroyed,\n      // clear out the reference to avoid leaking memory.\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n      this._dataChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    getParent() {\n      return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n      return this._tree._getNodeChildren(this);\n    }\n    /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n    focus() {\n      this._tabindex = 0;\n      if (this._shouldFocus) {\n        this._elementRef.nativeElement.focus();\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Defocus this data node. */\n    unfocus() {\n      this._tabindex = -1;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n    activate() {\n      if (this.isDisabled) {\n        return;\n      }\n      this.activation.next(this._data);\n    }\n    /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n    collapse() {\n      if (this.isExpandable) {\n        this._tree.collapse(this._data);\n      }\n    }\n    /** Expands this data node. Implemented for TreeKeyManagerItem. */\n    expand() {\n      if (this.isExpandable) {\n        this._tree.expand(this._data);\n      }\n    }\n    /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n    makeFocusable() {\n      this._tabindex = 0;\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._shouldFocus = false;\n      this._tree._keyManager.focusItem(this);\n      this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n      this.expandedChange.emit(expanded);\n    }\n    static ɵfac = function CdkTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNode,\n      selectors: [[\"cdk-tree-node\"]],\n      hostAttrs: [\"role\", \"treeitem\", 1, \"cdk-tree-node\"],\n      hostVars: 5,\n      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNode_click_HostBindingHandler() {\n            return ctx._setActiveItem();\n          })(\"focus\", function CdkTreeNode_focus_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n          i0.ɵɵattribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        role: \"role\",\n        isExpandable: [2, \"isExpandable\", \"isExpandable\", booleanAttribute],\n        isExpanded: \"isExpanded\",\n        isDisabled: [2, \"isDisabled\", \"isDisabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"cdkTreeNode\"]\n    });\n  }\n  return CdkTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getParentNodeAriaLevel(nodeElement) {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level'));\n  } else {\n    // The ancestor element is the cdk-tree itself\n    return 0;\n  }\n}\nfunction isNodeElement(element) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nlet CdkNestedTreeNode = /*#__PURE__*/(() => {\n  class CdkNestedTreeNode extends CdkTreeNode {\n    _type = 'nested';\n    _differs = inject(IterableDiffers);\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n    _children;\n    /** The children node placeholder. */\n    nodeOutlet;\n    constructor() {\n      super();\n    }\n    ngAfterContentInit() {\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n      this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());\n    }\n    ngOnDestroy() {\n      this._clear();\n      super.ngOnDestroy();\n    }\n    /** Add children dataNodes to the NodeOutlet */\n    updateChildrenNodes(children) {\n      const outlet = this._getNodeOutlet();\n      if (children) {\n        this._children = children;\n      }\n      if (outlet && this._children) {\n        const viewContainer = outlet.viewContainer;\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        // Reset the data differ if there's no children nodes displayed\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Clear the children dataNodes. */\n    _clear() {\n      const outlet = this._getNodeOutlet();\n      if (outlet) {\n        outlet.viewContainer.clear();\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Gets the outlet for the current node. */\n    _getNodeOutlet() {\n      const outlets = this.nodeOutlet;\n      // Note that since we use `descendants: true` on the query, we have to ensure\n      // that we don't pick up the outlet of a child node by accident.\n      return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static ɵfac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNestedTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkNestedTreeNode,\n      selectors: [[\"cdk-nested-tree-node\"]],\n      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-nested-tree-node\"],\n      exportAs: [\"cdkNestedTreeNode\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkNestedTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nlet CdkTreeNodePadding = /*#__PURE__*/(() => {\n  class CdkTreeNodePadding {\n    _treeNode = inject(CdkTreeNode);\n    _tree = inject(CdkTree);\n    _element = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n    _currentPadding;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** CSS units used for the indentation value. */\n    indentUnits = 'px';\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n      return this._level;\n    }\n    set level(value) {\n      this._setLevelInput(value);\n    }\n    _level;\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent() {\n      return this._indent;\n    }\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n    _indent = 40;\n    constructor() {\n      this._setPadding();\n      this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n      // In Ivy the indentation binding might be set before the tree node's data has been added,\n      // which means that we'll miss the first render. We have to subscribe to changes in the\n      // data to ensure that everything is up to date.\n      this._treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent() {\n      const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n      const level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n      const padding = this._paddingIndent();\n      if (padding !== this._currentPadding || forceChange) {\n        const element = this._element.nativeElement;\n        const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n        element.style[paddingProp] = padding || '';\n        element.style[resetProp] = '';\n        this._currentPadding = padding;\n      }\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setLevelInput(value) {\n      // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n      // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n      // they set 0 explicitly.\n      this._level = isNaN(value) ? null : value;\n      this._setPadding();\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setIndentInput(indent) {\n      let value = indent;\n      let units = 'px';\n      if (typeof indent === 'string') {\n        const parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n      this.indentUnits = units;\n      this._indent = numberAttribute(value);\n      this._setPadding();\n    }\n    static ɵfac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodePadding)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodePadding,\n      selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"cdkTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"cdkTreeNodePaddingIndent\", \"indent\"]\n      }\n    });\n  }\n  return CdkTreeNodePadding;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Node toggle to expand and collapse the node.\n */\nlet CdkTreeNodeToggle = /*#__PURE__*/(() => {\n  class CdkTreeNodeToggle {\n    _tree = inject(CdkTree);\n    _treeNode = inject(CdkTreeNode);\n    /** Whether expand/collapse the node recursively. */\n    recursive = false;\n    constructor() {}\n    // Toggle the expanded or collapsed state of this node.\n    //\n    // Focus this node with expanding or collapsing it. This ensures that the active node will always\n    // be visible when expanding and collapsing.\n    _toggle() {\n      this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);\n      this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static ɵfac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeToggle)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeToggle,\n      selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n      hostAttrs: [\"tabindex\", \"-1\"],\n      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.stopPropagation();\n          })(\"keydown.Enter\", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          })(\"keydown.Space\", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          });\n        }\n      },\n      inputs: {\n        recursive: [2, \"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute]\n      }\n    });\n  }\n  return CdkTreeNodeToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\nlet CdkTreeModule = /*#__PURE__*/(() => {\n  class CdkTreeModule {\n    static ɵfac = function CdkTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkTreeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return CdkTreeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n//# sourceMappingURL=tree.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}