{"ast":null,"code":"import _asyncToGenerator from \"/Users/gustavoferri/talc/talc_frontend_docker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { input, output, signal, viewChild, inject, NgZone, PLATFORM_ID, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { asapScheduler } from 'rxjs';\nconst _c0 = [\"chart\"];\nlet ChartComponent = /*#__PURE__*/(() => {\n  class ChartComponent {\n    constructor() {\n      this.chart = input();\n      this.annotations = input();\n      this.colors = input();\n      this.dataLabels = input();\n      this.series = input();\n      this.stroke = input();\n      this.labels = input();\n      this.legend = input();\n      this.markers = input();\n      this.noData = input();\n      this.fill = input();\n      this.tooltip = input();\n      this.plotOptions = input();\n      this.responsive = input();\n      this.xaxis = input();\n      this.yaxis = input();\n      this.forecastDataPoints = input();\n      this.grid = input();\n      this.states = input();\n      this.title = input();\n      this.subtitle = input();\n      this.theme = input();\n      this.autoUpdateSeries = input(true);\n      this.chartReady = output();\n      // If consumers need to capture the `chartInstance` for use, consumers\n      // can access the component instance through `viewChild` and use `computed`\n      // or `effect` on `component.chartInstance()` to monitor its changes and\n      // recompute effects or computations whenever `chartInstance` is updated.\n      this.chartInstance = signal(null);\n      this.chartElement = viewChild.required(\"chart\");\n      this.ngZone = inject(NgZone);\n      this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n    }\n    ngOnChanges(changes) {\n      if (!this.isBrowser) return;\n      this.ngZone.runOutsideAngular(() => {\n        asapScheduler.schedule(() => this.hydrate(changes));\n      });\n    }\n    ngOnDestroy() {\n      this.destroy();\n    }\n    hydrate(changes) {\n      const shouldUpdateSeries = this.autoUpdateSeries() && Object.keys(changes).filter(c => c !== \"series\").length === 0;\n      if (shouldUpdateSeries) {\n        this.updateSeries(this.series(), true);\n        return;\n      }\n      this.createElement();\n    }\n    createElement() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const {\n          default: ApexCharts\n        } = yield import('apexcharts');\n        window.ApexCharts ||= ApexCharts;\n        const options = {};\n        const properties = [\"annotations\", \"chart\", \"colors\", \"dataLabels\", \"series\", \"stroke\", \"labels\", \"legend\", \"fill\", \"tooltip\", \"plotOptions\", \"responsive\", \"markers\", \"noData\", \"xaxis\", \"yaxis\", \"forecastDataPoints\", \"grid\", \"states\", \"title\", \"subtitle\", \"theme\"];\n        properties.forEach(property => {\n          const value = _this[property]();\n          if (value) {\n            options[property] = value;\n          }\n        });\n        _this.destroy();\n        const chartInstance = _this.ngZone.runOutsideAngular(() => new ApexCharts(_this.chartElement().nativeElement, options));\n        _this.chartInstance.set(chartInstance);\n        _this.render();\n        _this.chartReady.emit({\n          chartObj: chartInstance\n        });\n      })();\n    }\n    render() {\n      return this.ngZone.runOutsideAngular(() => this.chartInstance()?.render());\n    }\n    updateOptions(options, redrawPaths, animate, updateSyncedCharts) {\n      return this.ngZone.runOutsideAngular(() => this.chartInstance()?.updateOptions(options, redrawPaths, animate, updateSyncedCharts));\n    }\n    updateSeries(newSeries, animate) {\n      return this.ngZone.runOutsideAngular(() => this.chartInstance()?.updateSeries(newSeries, animate));\n    }\n    appendSeries(newSeries, animate) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.appendSeries(newSeries, animate));\n    }\n    appendData(newData) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.appendData(newData));\n    }\n    highlightSeries(seriesName) {\n      return this.ngZone.runOutsideAngular(() => this.chartInstance()?.highlightSeries(seriesName));\n    }\n    toggleSeries(seriesName) {\n      return this.ngZone.runOutsideAngular(() => this.chartInstance()?.toggleSeries(seriesName));\n    }\n    showSeries(seriesName) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.showSeries(seriesName));\n    }\n    hideSeries(seriesName) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.hideSeries(seriesName));\n    }\n    resetSeries() {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.resetSeries());\n    }\n    zoomX(min, max) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.zoomX(min, max));\n    }\n    toggleDataPointSelection(seriesIndex, dataPointIndex) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.toggleDataPointSelection(seriesIndex, dataPointIndex));\n    }\n    destroy() {\n      this.chartInstance()?.destroy();\n      this.chartInstance.set(null);\n    }\n    setLocale(localeName) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.setLocale(localeName));\n    }\n    paper() {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.paper());\n    }\n    addXaxisAnnotation(options, pushToMemory, context) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.addXaxisAnnotation(options, pushToMemory, context));\n    }\n    addYaxisAnnotation(options, pushToMemory, context) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.addYaxisAnnotation(options, pushToMemory, context));\n    }\n    addPointAnnotation(options, pushToMemory, context) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.addPointAnnotation(options, pushToMemory, context));\n    }\n    removeAnnotation(id, options) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.removeAnnotation(id, options));\n    }\n    clearAnnotations(options) {\n      this.ngZone.runOutsideAngular(() => this.chartInstance()?.clearAnnotations(options));\n    }\n    dataURI(options) {\n      return this.chartInstance()?.dataURI(options);\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function ChartComponent_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || ChartComponent)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n        type: ChartComponent,\n        selectors: [[\"apx-chart\"]],\n        viewQuery: function ChartComponent_Query(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵviewQuerySignal(ctx.chartElement, _c0, 5);\n          }\n          if (rf & 2) {\n            i0.ɵɵqueryAdvance();\n          }\n        },\n        inputs: {\n          chart: [1, \"chart\"],\n          annotations: [1, \"annotations\"],\n          colors: [1, \"colors\"],\n          dataLabels: [1, \"dataLabels\"],\n          series: [1, \"series\"],\n          stroke: [1, \"stroke\"],\n          labels: [1, \"labels\"],\n          legend: [1, \"legend\"],\n          markers: [1, \"markers\"],\n          noData: [1, \"noData\"],\n          fill: [1, \"fill\"],\n          tooltip: [1, \"tooltip\"],\n          plotOptions: [1, \"plotOptions\"],\n          responsive: [1, \"responsive\"],\n          xaxis: [1, \"xaxis\"],\n          yaxis: [1, \"yaxis\"],\n          forecastDataPoints: [1, \"forecastDataPoints\"],\n          grid: [1, \"grid\"],\n          states: [1, \"states\"],\n          title: [1, \"title\"],\n          subtitle: [1, \"subtitle\"],\n          theme: [1, \"theme\"],\n          autoUpdateSeries: [1, \"autoUpdateSeries\"]\n        },\n        outputs: {\n          chartReady: \"chartReady\"\n        },\n        features: [i0.ɵɵNgOnChangesFeature],\n        decls: 2,\n        vars: 0,\n        consts: [[\"chart\", \"\"]],\n        template: function ChartComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵelement(0, \"div\", null, 0);\n          }\n        },\n        encapsulation: 2,\n        changeDetection: 0\n      });\n    }\n  }\n  return ChartComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst declarations = [ChartComponent];\nlet NgApexchartsModule = /*#__PURE__*/(() => {\n  class NgApexchartsModule {\n    /** @nocollapse */static {\n      this.ɵfac = function NgApexchartsModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || NgApexchartsModule)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: NgApexchartsModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return NgApexchartsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ng-apexcharts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ChartComponent, NgApexchartsModule };\n//# sourceMappingURL=ng-apexcharts.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}